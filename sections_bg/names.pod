=encoding utf8

=head1 Имена

Z<names>

X<names>
X<identifiers>

I<Имената> (или I<идентификаторите>) са навсякъде в Perl програмите: променливи, функции, пакети, класове,
дори файлови манипулатори. Всички тези имена започват с буква или долна черта. След това е допустима произволна
комбинация от букви, цифри и долни черти. 
Когато е в сила правилото C<utf8> (L<unicode>), можете да използвате всеки текстов символ
от UTF-8 в идентификаторите.
Ето всички валидни Perl идентификатори:

=begin programlisting

    my $name;
    my @_private_names;
    my %Names_to_Addresses;

    sub anAwkwardName3;

    # with use utf8; enabled
    package Ingy::DE<ouml>t::Net;

=end programlisting

А тези Perl идентификатори са невалидни:

=begin programlisting

    my $invalid name;
    my @3;
    my %~flags;

    package a-lisp-style-name;

=end programlisting

X<symbolic lookups>

I<Имената съществуват на-вече за удобство на програмиста>. Това важи само
за буквени имена, каквито се срещат във вашия изходен код, като C<sub
fetch_pie> или C<my $waffleiron>. Но единствено парсърът на Perl може да прилага правилата
за имена на идентификаторите.

Динамичният характер на Perl ви позволява да се обръщате към единиците с имена,
генерирани по време на изпълнение, или дадени им при входа на програмата.
Този метод за I<намиране на символи> предоставя гъвкавост, донякъде за сметка на сигурността.
По-специално, непрякото извикване на функции или методи или търсенето на символи
в пространство от имена ви дава възможност да заобиколите парсъра на Perl.

Такава практика може да доведе до доста объркващ код. Както Марк Джейсън Доминус препоръчва
много удачноN<U<http://perl.plover.com/varvarname.html>>, ползвайте хеш (L<hashes>)
или сложни структури от данни (L<nested_data_structures>).

=head2 Имена на променливи и Знаци

X<variables; names>
X<scalar variables>
X<variables; scalars>
X<scalars>
X<arrays>
X<variables; arrays>
X<hashes>
X<variables; hashes>
X<sigil>

I<Имената на променливите> винаги започват със I<знак> (или символ),
указващ типа стойност на променливата. I<Скаларните променливи> (L<scalars>) използват
знака за долар (C<$>). I<Масивите> (L<arrays>) се обозначават с маймунка (C<@>).
Пред I<хешовете> (L<hashes>) се слага знак за процент (C<%>):

=begin programlisting

    my $scalar;
    my @array;
    my %hash;

=end programlisting

Тези знаци предоставят видимо пространство от имена за променливите. 
Така е възможно--макар и объркващо--да се декларират множество променливи с еднакво име и от различни типове:

=begin programlisting

    my ($bad_name, @bad_name, %bad_name);

=end programlisting

Though Perl won't get confused, people reading this code will.

X<variant sigils>

Perl 5's sigils are I<variant sigils>. As context determines how many items you
expect from an operation or what type of data you expect to get, so the sigil
governs how you manipulate the data of a variable.  For example, to access a
single element of an array or a hash, you must use the scalar sigil (C<$>):

=begin programlisting

    my $hash_element  = $hash{ $key };
    my $array_element = $array[ $index ]

    $hash{ $key }     = 'value';
    $array[ $index ]  = 'item';

=end programlisting

X<lvalue>
X<rvalue>

The parallel with amount context is important. Using a scalar element of an
aggregate as an I<lvalue> (the target of an assignment, on the left side of the
C<=> character) imposes scalar context (L<context_philosophy>) on the I<rvalue>
(the value assigned, on the right side of the C<=> character).

X<slices>

Similarly, accessing multiple elements of a hash or an array--an operation
known as I<slicing>--uses the at symbol (C<@>) and imposes list contextN<...
even if the list itself has zero or one elements>:

=begin programlisting

    my @hash_elements  = @hash{ @keys };
    my @array_elements = @array[ @indexes ];

    my %hash;
    @hash{ @keys }     = @values;

=end programlisting

The most reliable way to determine the type of a variable--scalar, array, or
hash--is to look at the operations performed on it. Scalars support all basic
operations, such as string, numeric, and boolean manipulations. Arrays support
indexed access through square brackets. Hashes support keyed access through
curly brackets.

=head2 Namespaces

X<fully-qualified name>
X<namespaces>

Perl provides a mechanism to group similar functions and variables into their
own unique named spaces--I<namespaces> (L<packages>). A namespace is a named
collection of symbols. Perl allows multi-level namespaces, with names joined by
double colons (C<::>), where C<DessertShop::IceCream> refers to a logical
collection of related variables and functions, such as C<scoop()> and
C<pour_hot_fudge()>.

Within a namespace, you may use the short name of its members. Outside of the
namespace, refer to a member using its I<fully-qualified name>. That is, within
C<DessertShop::IceCream>, C<add_sprinkles()> refers to the same function as
does C<DessertShop::IceCream::add_sprinkles()> outside of the namespace.

While standard naming rules apply to package names, by convention user-defined
packages all start with uppercase letters. The Perl core reserves lowercase
package names for core pragmas (L<pragmas>), such as C<strict> and C<warnings>.
This is a policy enforced primarily by community guidelines.

All namespaces in Perl 5 are globally visible. When Perl looks up a symbol in
C<DessertShop::IceCream::Freezer>, it looks in the C<main::> symbol table for a
symbol representing the C<DessertShop::> namespace, then in there for the
C<IceCream::> namespace, and so on. The C<Freezer::> is visible from outside of
the C<IceCream::> namespace. The nesting of the former within the latter is
only a storage mechanism, and implies nothing further about relationships
between parent and child or sibling packages. Only a programmer can make
I<logical> relationships between entities obvious--by choosing good names and
organizing them well.
