=encoding utf8

=head1 Деклариране на функции

Z<functions>

X<functions; declaration>
X<builtins; C<sub>>

Функция се декларира посредством резервираната дума C<sub>:

=begin programlisting

    B<sub> greet_me  { ... }

=end programlisting

По този начин функцията C<greet_me()> е декларирана и готова 
да бъде ползвана на което и да е масто в нашата програма.

X<функции; предварително деклариране>

Не е наложително да I<дефинирате> всяка функция при декларирането й. 
I<предварителното деклариране> указва на Perl да резервира името на тази
функция, и че дефиницията й ще последва по-нататък:

=begin programlisting

    sub greet_sun;

=end programlisting

=head1 Стартиране на функции

X<functions; invoking>

Използвайки името на функцията последвано от
отваряща и затваряща скоби, предизвиквате стартирането й, като 
също е възможно да подадете входни данни( обикновено наричани - аргументи):

=begin programlisting

    greet_me( 'Jack', 'Brad' );
    greet_me( 'Snowy' );
    greet_me();

=end programlisting

В примерите по-горе скобите не са абсолютно задължителни, дори и да 
използвате прагмата C<strict> --те просто внасят прегледност при четене
на кода и улесняват парсера на Perl. Ако се зачудите дали да се слагат или
не, по-добре е да ги има.

Аргументите подавани на една функция могат да бъдат всякакви изрази, 
както и обикновени промениливи.

=begin programlisting

    greet_me( $name );
    greet_me( @authors );
    greet_me( %editors );

=end programlisting

... имайте предвид обаче, че подходът на Perl 5 използван по подразбиране 
за обработка на аргументи на функция, може да обърка по неопитните.

=head1 Аргументи подадени към функция

Z<function_parameters>

X<parameters>
X<functions; parameters>
X<C<@_>>
X<parameters; flattening>

Всяка функция получава аргументите си посредством масив, C<@_>
(L<default_array_variables>). Perl I<flattens> всички подадени аргументи 
във формат на списък. Функцията трябва или да "разопакова" аргументите в 
отделни промениливи, или да работи директно с масива C<@_>:

=begin programlisting

    sub greet_one
    {
        B<my ($name) = @_>;
        say "Hello, $name!";
    }

    sub greet_all
    {
        say "Hello, B<$_!" for @_>;
    }

=end programlisting

Повечето програмисти ползват или C<shift>, или разопаковат списъка. Обаче C<@_> 
може да се използва като обикновен масив, можете да достъпите отделните му елементи
посредсвом поредния им номер:

=begin programlisting

    sub greet_one_shift
    {
        B<my $name = shift>;
        say "Hello, $name!";
    }

    sub greet_two_no_shift
    {
        my ($hero, $sidekick) = @_;
        say "Well if it isn't $hero and $sidekick. Welcome!";
    }

    sub greet_one_indexed
    {
        B<my $name = $_[0]>;
        say "Hello, $name!";

        # or, less clear
        say "Hello, $_[0]!";
    }

=end programlisting

... можете да ползвате C<shift>, C<unshift>, C<push>, C<pop>, C<splice>, както и част от C<@_>.

=begin tip The Implicit Them

Струва си да се запомни, че вградените операции работещи с масиви
използват C<@_> като аргумент по подразбиране I<вътре във функцията>. 
И вие бихте могли да се възползвате от това удобсво.

=end tip

За да ползвате в скаларен контекст един от подадените параметри  от масива C<@_>
е необходимо да използвате C<shift>, достъп до даден индекс от масива C<@_>, 
или израз в списъчен контекст посредсвом скоби. В противен случай, Perl 5 любезно 
ще изрази масива C<@_> в скаларен контекст и ще ви даде броя на подадените параметри:

=begin programlisting

    sub bad_greet_one
    {
        B<my $name = @_>;  # buggy
        say "Hello, $name; you look numeric today!"
    }

=end programlisting

Отделянето на стойностите на аргументите в списъчен контекст често
е по-лесно за четене от множество редове ползващи C<shift>. 
Например:

=begin programlisting

    sub calculate_value
    {
        # multiple shifts
        my $left_value  = shift;
        my $operation   = shift;
        my $right_value = shift;
        ...
    }

=end programlisting

... сравнено с:

=begin programlisting

    sub calculate_value
    {
        B<my ($left_value, $operation, $right_value) = @_;>
        ...
    }

=end programlisting

Понякога се налага само част от аргументите да бъдат извлечени от C<@_> ,
а останалите да бъдат подадени към друга функция:

=begin programlisting

    sub delegated_method
    {
        my $self = B<shift>;
        say 'Calling delegated_method()'

        $self->delegate->delegated_method( B<@_> );
    }

=end programlisting

Ползвайте C<shift> когато подавате само един аргумент на функциите си. Когато има 
повече аргументи е по-удачно да се ползва списъчно подаване на стойности за променивите.

=begin tip Real Function Signatures

X<CPAN; C<signatures>>
X<CPAN; C<Method::Signatures>>
X<CPAN; C<MooseX::Method::Signatures>>
X<CPAN; C<Method::Signatures::Simple>>

Няколко CPAN дистрибуции разширяват обработката на аргументи от Perl 5
добавяйки нов синтаксис и нови опции.
C<signatures> и C<Method::Signatures> са с огромни възможности.
C<Method::Signatures::Simple> е по-простичка, но доста полезна дистрибуция.
C<MooseX::Method::Signatures> работи великолепно с Moose (L<moose>).

=end tip

=head2 Flattening

Превръщането на аргументите в списък C<@_> се прави още при извикването
на функцията. Подаване на hash като аргумент подава на функцията списък с 
двойки ключ/стойност:

=begin programlisting

    my %pet_names_and_types = (
        Lucky   => 'dog',
        Rodney  => 'dog',
        Tuxedo  => 'cat',
        Petunia => 'cat',
    );

    show_pets( %pet_names_and_types );

    sub show_pets
    {
        my %pets = @_;
        while (my ($name, $type) = each %pets)
        {
            say "$name is a $type";
        }
    }

=end programlisting

Когато Perl превърне C<%pet_names_and_types> в списък, подредбата на двойките
ключ/стойност на hash-а ще е различна, но винаги списъкът ще съдържа ключ 
непосредствено последван от своята стойност. Присвояването на Hash в C<show_pets()> 
работи по същтия начин както по-явното присвояване C<%pet_names_and_types>.

Превръщането на аргументите в списък често е полезно, но трябва да се внимава
при смесването на скаларни и съставни аргументи при подаването на аргументи на функция.
При писането на функция C<show_pets_of_type()>, на която подаваме един аргумент за вид
домашен любимец за показване, добре е да се подаде вида като I<първи> аргумент 
(или като последен и да се ползва C<pop> за да извадим аргумента от края на масива C<@_>):

=begin programlisting

    sub show_pets_by_type
    {
        B<my ($type, %pets) = @_>;

        while (my ($name, $species) = each %pets)
        {
            B<next unless $species eq $type;>
            say "$name is a $species";
        }
    }

    my %pet_names_and_types = (
        Lucky   => 'dog',
        Rodney  => 'dog',
        Tuxedo  => 'cat',
        Petunia => 'cat',
    );

    show_pets_by_type( 'dog',   %pet_names_and_types );
    show_pets_by_type( 'cat',   %pet_names_and_types );
    show_pets_by_type( 'moose', %pet_names_and_types );

=end programlisting

=head2 Изсмукване на аргументи (Slurping)

Z<parameter_slurping>
X<parameters; slurping>

Приравняването към съставен тип променливи изсмуква всички аргументи, 
например приравняването към C<%pets> I<изсмуква> всички оставащи стойности 
от списък C<@_>. Ако C<$type> аргумента е поставен на края на списъка C<@_>, 
Perl ще даде предупреждение за нечетен брой елемента в hash-а. Вие I<бихте могли> 
да избегнете това:

=begin programlisting

    sub show_pets_by_type
    {
        B<my $type = pop;>
        B<my %pets = @_;>

        ...
    }

=end programlisting

... за сметка на яснотата на кода. Същия принцип може да се приложи и когато се
подават стойностите на масив като аргумент. Използвайте указатели (L<references>) 
за да избегнете преобразуването в списък и изсмукването на аргументи.

=head2 Псевдоними

X<parameters; aliasing>
X<functions; aliasing parameters>

При списъка C<@_> има една малка подробност; той създава I<псевдоними> на 
аргументите подадени към функцията така че те могат да бъдат променяни. 
На пример:

=begin programlisting

    sub modify_name
    {
        $_[0] = reverse $_[0];
    }

    my $name = 'Orange';
    modify_name( $name );
    say $name;

    # prints C<egnarO>

=end programlisting

Ако промените елемент директно в списъка C<@_> това ще промени и оригиналния
параметър.
Бъдете внимателни, и разопаковайте C<@_> преди употреба на аргументите.

=head1 Функции и Именовани-пространсва 

Всяка функция се съдържа в някое именовано-пространство (L<packages>). Функциите
от недекларирано именовано-пространство --функциите които не са декларирани
след изрична употреба на C<package> директивата--се съдържат в главното C<main> 
именовано-пространство. Можете да декларирате функция в различно 
именовано-пространство като поставите неговото име пред името на функцията:

=begin programlisting

    sub B<Extensions::Math::>add {
        ...
    }

=end programlisting

Този код ще декларира функцията и ще създаде именованото-пространство,
 ако е необходимо. Трябва да се запомни че пакетите на Perl 5 са отворени
 за промени във всеки момент. В едно именовано-пространство е възможно 
 да се декларира само една функция с дадено име . В противен случай Perl 5 
 ще издаде предупреждение за предефиниране на функция. 
Тези предупреждения могат да бъдат спрени с употребата на C<no warnings
'redefine'>--при положение че сте убедени че имате нужда от това.

Извикването на функции от дтуги именовани-пространства става
чрез употреба на пълното квалифициращо име на функцията:

=begin programlisting

    package main;

    Extensions::Math::add( $scalar, $vector );

=end programlisting

Функции принадлежащи на дадено именовано-пространство стават I<видими> за програмата
посредством употребата на пълното им квалифициращо име. Вътре в именованото-
пространство, можете да използвате съкратеното име на функциите декларирани в това
именовано-пространство. Можете също така да импортирате (вкарате) имена на функции от други 
именовани-пространства.

=head2 Импортване

Z<importing>

X<functions; importing>
X<builtins; C<use>>

Когато се зарежда модул (L<modules>) с вградената директива C<use> , Perl автоматично
извиква метода C<import()> на този модул. Модулите могат да осигурят свой собствен 
C<import()> метод, който подсигурява че са на разположение някои или всички дефинирани
символи от извикващия пакет. Всички аргументи следващи името на модула при 
C<use> директивата биват подадени на метода C<import()> на модула. По този начин:

=begin programlisting

    use strict;

=end programlisting

... зарежда модула F<strict.pm> и извиква неговия метод C<< strict->import() >> 
без аргументи, докато:

=begin programlisting

    use strict 'refs';
    use strict qw( subs vars );

=end programlisting

... зарежда модула F<strict.pm>, извиква C<< strict->import( 'refs' ) >>, 
и след това C<< strict->import( 'subs', vars' ) >>.

C<use> има специално поведение спрямо C<import()>, но вие можете да извикате
C<import()> директно. Предишния пример с C<use> е еквивалентен на:

=begin programlisting

    BEGIN
    {
        require strict;
        strict->import( 'refs' );
        strict->import( qw( subs vars ) );
    }

=end programlisting

Вградената директива C<use> добавя по подразбиране блок C<BEGIN> около тези изрази
така че извикването на C<import()> се случва I<непосредствено> след като парсерът 
е компилирал изцяло директивата C<use>. Това осигурява че всички импортирани 
символи за на разположение при компилацията на отаналата част от програмата. 
В противен случай, всички функции I<импортирани> от други модули, които не са
 I<декларирани> в настоящия файл ще приличат на голи думи, и ще нарушат 
 директивата C<strict>.

=head1 Reporting Errors

Z<reporting_errors>
X<builtins; C<caller>>

Within a function, inspect the context of the call to the function with the
C<caller> builtin. When passed no arguments, it returns a three element list
containing the name of the calling package, the name of the file containing the
call, and the line number of the file on which the call occurred:

=begin programlisting

    package main;

    main();

    sub main
    {
        show_call_information();
    }

    sub show_call_information
    {
        my ($package, $file, $line) = caller();
        say "Called from $package in $file:$line";
    }

=end programlisting

The full call chain is available for inspection. Pass a single integer argument
I<n> to C<caller()> to inspect the caller of the caller of the caller I<n>
times. In other words, if C<show_call_information()> used C<caller(0)>, it
would receive information about the call from C<main()>. If it used
C<caller(1)>, it would receive information about the call from the start of the
program.

This optional argument also tells C<caller> to provide additional return
values, including the name of the function and the context of the call:

=begin programlisting

    sub show_call_information
    {
        my ($package, $file, $lineB<, $func>) = caller(B<0>);
        say "Called B<$func> from $package in $file:$line";
    }

=end programlisting

X<C<Carp>>
X<C<Carp>; C<croak()>>
X<C<Carp>; C<carp()>>

The standard C<Carp> module uses this technique to great effect for reporting
errors and throwing warnings in functions. When used in place of C<die> in
library code, C<croak()> throws an exception from the point of view of its
caller. C<carp()> reports a warning from the file and line number of its caller
(L<producing_warnings>).

This behavior is most useful when validating parameters or preconditions of a
function to indicate that the calling code is wrong somehow.

=head2 Validating Arguments

While Perl does its best to do what the programmer means, it offers few native
ways to test the validity of arguments provided to a function. Evaluate C<@_>
in scalar context to check that the I<number> of parameters passed to a
function is correct:

=begin programlisting

    sub add_numbers
    {
        croak 'Expected two numbers, received: ' . @_
            unless @_ == 2;

        ...
    }

=end programlisting

X<CPAN; C<Params::Validate>>

Type checking is more difficult, because of Perl's operator-oriented type
conversions (L<context_philosophy>). The CPAN module C<Params::Validate> offers
more strictness.

=head1 Advanced Functions

Functions are the foundation of many advanced Perl features.

=head2 Context Awareness

X<context>
X<C<wantarray>>
X<builtins; C<wantarray>>

Perl 5's builtins know whether you've invoked them in void, scalar, or list
context. So too can your functions. The misnamedN<See C<perldoc -f wantarray>
to verify.> C<wantarray> builtin returns C<undef> to signify void context, a
false value to signify scalar context, and a true value to signify list
context.

=begin programlisting

    sub context_sensitive
    {
        my $context = wantarray();

        return qw( List context )   if         $context;
        say    'Void context'   unless defined $context;
        return 'Scalar context' unless         $context;
    }

    context_sensitive();
    say my $scalar = context_sensitive();
    say context_sensitive();

=end programlisting

This can be useful for functions which might produce expensive return values to
avoid doing so in void context. Some idiomatic functions return a list in list
context and the first element of the list or an array reference in scalar
context. Yet remember that there exists no single best recommendation for the
use C<wantarray>. Sometimes it's clearer to write separate and unambiguous
functions.

=begin tip Putting it in Context

X<C<Want>>
X<C<Contextual::Return>>

Robin Houston's C<Want> and Damian Conway's C<Contextual::Return> distributions
from the CPAN offer many possibilities for writing powerful and usable
context-aware interfaces.

=end tip

=head2 Recursion

Z<recursion>
X<recursion>
X<call frame>
X<functions; call frame>

Suppose you want to find an element in a sorted array. You I<could> iterate
through every element of the array individually, looking for the target, but on
average, you'll have to examine half of the elements of the array. Another
approach is to halve the array, pick the element at the midpoint, compare, then
repeat with either the lower or upper half. Divide and conquer. When you run
out of elements to inspect or find the element, stop.

An automated test for this technique could be:

=begin programlisting

    use Test::More;

    my @elements =
    (
        1, 5, 6, 19, 48, 77, 997, 1025, 7777, 8192, 9999
    );

    ok   elem_exists(     1, @elements ),
            'found first element in array';
    ok   elem_exists(  9999, @elements ),
             'found last element in array';
    ok ! elem_exists(   998, @elements ),
            'did not find element not in array';
    ok ! elem_exists(    -1, @elements ),
            'did not find element not in array';
    ok ! elem_exists( 10000, @elements ),
            'did not find element not in array';

    ok   elem_exists(    77, @elements ),
            'found midpoint element';
    ok   elem_exists(    48, @elements ),
            'found end of lower half element';
    ok   elem_exists(   997, @elements ),
            'found start of upper half element';

    done_testing();

=end programlisting

Recursion is a deceptively simple concept. Every call to a function in Perl
creates a new I<call frame>, an internal data structure which represents the
call itself, including the lexical environment of the function's current
invocation. This means that a function can call itself, or I<recur>.

To make the previous test pass, write a function called C<elem_exists()> which
knows how to call itself, halving the list each time:

=begin programlisting

    sub elem_exists
    {
        my ($item, @array) = @_;

        # break recursion with no elements to search
        return unless @array;

        # bias down with odd number of elements
        my $midpoint = int( (@array / 2) - 0.5 );
        my $miditem  = $array[ $midpoint ];

        # return true if found
        return 1 if $item  == $miditem;

        # return false with only one element
        return   if @array == 1;

        # split the array down and recurse
        return B<elem_exists>(
            $item, @array[0 .. $midpoint]
        ) if $item < $miditem;

        # split the array and recurse
        return B<elem_exists>(
             $item, @array[ $midpoint + 1 .. $#array ]
        );
    }

=end programlisting

While you I<can> write this code in a procedural way and manage the halves of
the list yourself, this recursive approach lets Perl manage the bookkeeping.

=head2 Lexicals

Every new invocation of a function creates its own I<instance> of a lexical
scope. Even though the declaration of C<elem_exists()> creates a single scope
for the lexicals C<$item>, C<@array>, C<$midpoint>, and C<$miditem>, every
I<call> to C<elem_exists()>--even recursively--stores the values of those
lexicals separately.

Not only can C<elem_exists()> call itself, but the lexical variables of each
invocation are safe and separate:

=begin programlisting

    B<use Carp 'cluck';>

    sub elem_exists
    {
        my ($item, @array) = @_;

        B<cluck "[$item] (@array)";>

        # other code follows
        ...
    }

=end programlisting

=head2 Tail Calls

Z<tail_calls>
X<recursion; guard conditions>

One I<drawback> of recursion is that you must get your return conditions
correct, lest your function call itself an infinite number of times.
C<elem_exists()> function has several C<return> statements for this reason.

Perl offers a helpful C<Deep recursion on subroutine> warning when it suspects
runaway recursion. The limit of 100 recursive calls is arbitrary, but often
useful. Disable this warning with C<no warnings 'recursion'> in the scope of
the recursive call.

Because each call to a function requires a new call frame and lexical storage
space, highly-recursive code can use more memory than iterative code. I<Tail
call elimination> can help.

A I<tail call> is a call to a function which directly returns that function's
results. These recursive calls to C<elem_exists()>:

=begin programlisting

    # split the array down and recurse
    return B<elem_exists>(
        $item, @array[0 .. $midpoint]
    ) if $item < $miditem;

    # split the array and recurse
    return B<elem_exists>(
         $item, @array[ $midpoint + 1 .. $#array ]
    );

=end programlisting

... are candidates for tail call elimination. This optimization would avoid
returning to the current call and then returning to the parent call. Instead,
it returns to the parent call directly.

X<C<goto>>
X<functions; C<goto>>
X<builtins; C<goto>>

Unfortunately, Perl 5 does not eliminate tail calls automatically. Do so
manually with a special form of the C<goto> builtin. Unlike the form which
often produces spaghetti code, the C<goto> function form replaces the current
function call with a call to another function. You may use a function by name
or by reference. To pass different arguments, assign to C<@_> directly:

=begin programlisting

    # split the array down and recurse
    if ($item < $miditem)
    {
        @_ = ($item, @array[0 .. $midpoint]);
        B<goto &elem_exists;>
    }

    # split the array up and recurse
    else
    {
        @_ = ($item, @array[$midpoint + 1 .. $#array] );
        B<goto &elem_exists;>
    }

=end programlisting

Sometimes optimizations are ugly.

=head1 Pitfalls and Misfeatures

X<functions; misfeatures>
X<functions; Perl 4>
X<functions; Perl 1>
X<C<&>; sigil>
X<sigils; C<&>>
X<builtins; C<do>>

Perl 5 still supports old-style invocations of functions, carried over from
older versions of Perl. While you may now invoke Perl functions by name,
previous versions of Perl required you to invoke them with a leading ampersand
(C<&>) character. Perl 1 required you to use the C<do> builtin:

=begin programlisting

    # outdated style; avoid
    my $result = &calculate_result( 52 );

    # Perl 1 style; avoid
    my $result = do calculate_result( 42 );

    # crazy mishmash; really truly avoid
    my $result = do &calculate_result( 42 );

=end programlisting

While the vestigial syntax is visual clutter, the leading ampersand form has
other surprising behaviors. First, it disables any prototype checking. Second,
it I<implicitly> passes the contents of C<@_> unmodified unless you specify
arguments yourself. Both can lead to surprising behavior.

A final pitfall comes from leaving the parentheses off of function calls. The
Perl 5 parser uses several heuristics to resolve ambiguous barewords and the
number of parameters passed to a function. Heuristics can be wrong:

=begin programlisting

    # warning; contains a subtle bug
    ok elem_exists 1, @elements, 'found first element';

=end programlisting

The call to C<elem_exists()> will gobble up the test description intended as
the second argument to C<ok()>. Because C<elem_exists()> uses a slurpy second
parameter, this may go unnoticed until Perl produces warnings about comparing a
non-number (the test description, which it cannot convert into a number) with
the element in the array.

While extraneous parentheses can hamper readability, thoughtful use of
parentheses can clarify code and make subtle bugs unlikely.
